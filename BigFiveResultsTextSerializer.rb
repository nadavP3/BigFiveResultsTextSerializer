require 'net/http'
require 'net/https'
require 'uri'
require 'json'

class BigFiveResultsTextSerializer
# Converts the textual results of a test into a hash.
# Test results are generated by [Redacted]
  attr_reader :hash_results

  public
  def initialize(text)
    if text.size === 0
      abort("Looks like no text was provided, program will now exit.")
    end
      text.gsub!(/\r\n?/, "\n")                                   # This line is not required on Microsoft Windows 10 machines:
                                                                  # For whatever reason the "File.read" method works differently on Windows and doesn't add "\r".
                                                                  # Presence of "\r" in the return value, on MacOS*, causes the regex to fail matching,
                                                                  # This means that our code to only capture test subject's name (no test results or even titles).
                                                                  # * Tested on MacOS High Sierra 10.13.3 / This percussion eliminates a situation in which the program could fail on non-Windows machines.
      measurement_regex = /(?<=.\ Score\n\n)(.*?)(?=Your )/m      # Returns all test's titles and scores.
      name_regex = /(?<=compares)(.*?)(?=from the)/               # Returns test taker's name.

      @name = text.scan(name_regex)
      @name[0].join

      if @name.size === 0.
        @name = "John Doe"
      end

      measurements = text.scan(measurement_regex).to_a
      if measurements.empty?
        abort("Something went wrong, no matching data was detected, program will now exit.")
      end
      @initialization_results = process_measurements(measurements)

      hash_it
  end

  private
  def process_measurements(measurements)
    subdomain_regex = /(^[A-Z][a-zA-Z\s\-]+)\.+([0-9]+)\n/      # Returns the all exam sets.

    process_measurements_results = []
    measurements.each do |measurement|                         # Evaluating each exam.
      measure = measurement[0].to_s
      subdomains = measure.scan(subdomain_regex)               # Paticular exam set's content.
      domain = subdomains.shift                                # Exam's title and score.
      process_measurements_results << [domain[1],domain[2],subdomains]
    end
      process_measurements_results
  end

  def hash_it
    @hash_results = Hash.new
    @hash_results["NAME"] = @name[0][0]

    @initialization_results.each do |result|
      facets = Hash[result.last.map{|key, val| [key,val]}]
      @hash_results[result[0]] = {"Overall Score" => result[1], "Facets" => facets}
    end
  end

end


class BigFiveResultsPoster
  attr_reader :token, :response_code

  public
  def initialize(results_hash, email)
    email_regex = /^([a-zA-Z0-9_\-\.]+)@([a-zA-Z0-9_\-\.]+)\.([a-zA-Z]{2,5})$/

    @data = results_hash.hash_results     # Not the best name, yet neccery;
                                          # results_hash (as required by specifications), is an object of the BigFiveResultsTextSerializer class.
                                          # hash_results is an object of the hash class, it also contains the data that we need in the format that we need it.

    if @data.empty?
      abort("Something went wrong, the hash is empty, program will now exit.")
    end

    if !email.match(email_regex)
      abort("No valid email was provided, program will now exit.")
    end
    @data["EMAIL"] = email

    post
  end

  private
  def post
    uri = URI.parse("www.google.com") # To be replaced with actual site address once security clearance is granted

    header = {'Content-Type' => 'text/json'}

    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE
    request = Net::HTTP::Post.new(uri.request_uri, header)
    request.body = @data.to_json

    p response = http.request(request)
    p @response_code = response.code
    p @token = response.body

    @response_code === "201" # Operation succeeded?

  end

end
